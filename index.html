<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç‰¹æ–¯æ‹‰(TSLA)æ¨¡æ‹Ÿäº¤æ˜“ç­–ç•¥è·Ÿè¸ª</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }

        body {
            background: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        #globalWarning {
            background: linear-gradient(90deg, #ff3b30, #ff6b6b);
            color: white;
            padding: 10px 20px;
            text-align: center;
            font-size: 0.9rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        #globalWarning button {
            margin-left: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 2px 10px;
            border-radius: 3px;
            cursor: pointer;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 8px;
        }

        h1 {
            font-size: 2.8rem;
            background: linear-gradient(90deg, #00c9ff, #92fe9d);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 00px;
            font-weight: 700;
        }

        .stats-bar {
            display: flex;
            justify-content: space-between;
            background: rgba(40, 40, 40, 0.8);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stat-item {
            text-align: center;
            flex: 1;
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: 700;
            color: #4cd964;
            text-shadow: 0 0 10px rgba(76, 217, 100, 0.3);
        }

        .stat-label {
            font-size: 1rem;
            color: #aaa;
            margin-top: 5px;
        }

        .chart-container {
            display: flex;
            margin-bottom: 8px;
        }

        .chart-box {
            flex: 1;
            background: rgba(40, 40, 40, 0.8);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .chart-title {
            font-size: 1.4rem;
            margin-bottom: 0px;
            color: #fff;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .chart-title i {
            color: #4cd964;
        }

        /* Kçº¿æ•°é‡é€‰æ‹©å™¨æ ·å¼ */
        .kline-count-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .kline-count-btn {
            background: rgba(60, 60, 60, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            padding: 2px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            min-width: 50px;
            text-align: center;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .kline-count-btn:hover {
            background: rgba(80, 80, 80, 0.9);
            color: #fff;
        }

        .kline-count-btn.active {
            background: rgba(76, 217, 100, 0.2);
            color: #4cd964;
            border-color: #4cd964;
        }

        .chart {
            height: 500px;
            width: 100%;
        }

        .data-table-container {
            background: rgba(40, 40, 40, 0.8);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
            overflow-x: auto;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .table-title {
            font-size: 1.4rem;
            color: #fff;
            text-align: center;
            width: 100%;
        }

        .update-info {
            color: #aaa;
            font-size: 0.9rem;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th {
            background: rgba(0, 0, 0, 0.5);
            padding: 16px 12px;
            text-align: left;
            font-weight: 600;
            color: #fff;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .data-table td {
            padding: 14px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .data-table tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .data-table tr:last-child td {
            border-bottom: none;
        }

        .buy-operation {
            color: #ff3b30;
            background: rgba(255, 59, 48, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .sell-operation {
            color: #4cd964;
            background: rgba(76, 217, 100, 0.1);
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .auto-update-status {
            display: inline-flex;
            align-items: center;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
            font-size: 0.9rem;
            color: #aaa;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4cd964;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(76, 217, 100, 0.3);
            border-radius: 50%;
            border-top-color: #4cd964;
            animation: spin 1s linear infinite;
        }

        .error-message {
            background: rgba(255, 59, 48, 0.2);
            border: 1px solid rgba(255, 59, 48, 0.3);
            color: #ff3b30;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .timestamp-display {
            color: #aaa;
            font-size: 0.85rem;
        }

        .disclaimer-footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #777;
            font-size: 0.85rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .disclaimer-footer p {
            margin-top: 2px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5;
        }

        #disclaimerModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 9999;
            padding: 20px;
        }

        .modal-content {
            background: #2a2a2a;
            max-width: 1000px;
            width: 90%;
            margin: 50px auto;
            padding: 30px;
            border-radius: 12px;
            color: #fff;
            position: relative;
            max-height: 800px;
            display: flex;
            flex-direction: column;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .modal-title {
            color: #ff3b30;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        .modal-body {
            line-height: 1.6;
            overflow-y: auto;
            padding-right: 10px;
            flex: 1;
        }

        .modal-body p {
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .modal-body strong {
            color: #4cd964;
            font-weight: 600;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% {
                opacity: 0.10;
                box-shadow: 0 0 15px rgba(76, 217, 100, 0.3);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 15px rgba(76, 217, 100, 0.8);
            }
            100% {
                opacity: 0.10;
                box-shadow: 0 0 15px rgba(76, 217, 100, 0.3);
            }
        }

        @media (max-width: 768px) {
            .chart-container { flex-direction: column; }
            .stats-bar { flex-wrap: wrap; }
            .stat-item { flex: 0 0 33.33%; margin-bottom: 15px; }
            h1 { font-size: 2.2rem; }
            .chart { height: 400px; }
            .auto-update-status { flex-direction: column; align-items: center; text-align: center; }
            .modal-content { width: 95%; max-height: 80vh; padding: 20px; }
            .modal-title { font-size: 1.5rem; }
            .modal-body p { font-size: 1rem; }
            .chart-title {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .kline-count-selector {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div id="globalWarning">
        <i class="fas fa-exclamation-circle"></i>
        <strong>æ¨¡æ‹Ÿäº¤æ˜“å›æµ‹ç³»ç»Ÿ - ä¸æ„æˆæŠ•èµ„å»ºè®®</strong>
        <button onclick="showDisclaimerModal()">æŸ¥çœ‹å®Œæ•´å£°æ˜</button>
    </div>

    <div id="loadingOverlay" class="loading-overlay" style="display: flex;">
        <div class="loading-spinner"></div>
        <div style="color: #4cd964; margin-left: 20px;">æ­£åœ¨åŠ è½½æ•°æ®...</div>
    </div>

    <div class="container" id="mainContainer" style="display: none;">
        <header>
            <h1>ç‰¹æ–¯æ‹‰(TSLA)æ¨¡æ‹Ÿäº¤æ˜“ç­–ç•¥è·Ÿè¸ª</h1>
            <div class="auto-update-status">
                <span class="status-indicator"></span>
                <span>æœ€åæ›´æ–°: <span id="lastUpdateTime" class="timestamp-display">åŠ è½½ä¸­...</span></span>
            </div>
        </header>

        <div class="stats-bar">
            <div class="stat-item">
                <div class="stat-value" id="totalPnl">-</div>
                <div class="stat-label">æ€»æ”¶ç›Š</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="maxDrawdown">-</div>
                <div class="stat-label">æœ€å¤§å›æ’¤</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="maxDrawdownDays">-</div>
                <div class="stat-label">æœ€å¤§å›æ’¤å¤©æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="totalPositions">-</div>
                <div class="stat-label">æŒä»“æ•°é‡</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="tradeCount">-</div>
                <div class="stat-label">äº¤æ˜“æ¬¡æ•°</div>
            </div>
        </div>

        <div class="chart-container">
            <div class="chart-box">
                <div class="chart-title">
                    <div style="text-align: center;">
                        <span><i class="fas fa-chart-candlestick"></i> ä»·æ ¼ä¸æ”¶ç›Š</span>
                    </div>
                    <div class="kline-count-selector">
                        <button class="kline-count-btn" data-count="26">1å¤©</button>
                        <button class="kline-count-btn active" data-count="130">1å‘¨</button>
                        <button class="kline-count-btn" data-count="546">1æœˆ</button>
                        <button class="kline-count-btn" data-count="6552">1å¹´</button>
                        <button class="kline-count-btn" data-count="999999">å…¨éƒ¨</button>
                    </div>
                </div>
                <div id="combinedChart" class="chart"></div>
            </div>
        </div>

        <div class="data-table-container">
            <div class="table-header">
                <h2 class="table-title">äº¤æ˜“è®°å½•</h2>
            </div>
            <table class="data-table">
                <thead>
                    <tr>
                        <th>æ—¥æœŸ (ç¾ä¸œæ—¶é—´)</th>
                        <th>å¼€ç›˜ä»·</th>
                        <th>æœ€é«˜ä»·</th>
                        <th>æœ€ä½ä»·</th>
                        <th>æ”¶ç›˜ä»·</th>
                        <th>æ“ä½œ</th>
                        <th>ç­–ç•¥</th>
                        <th>æŒä»“</th>
                        <th>ä»·æ ¼</th>
                        <th>å‡€å€¼</th>
                    </tr>
                </thead>
                <tbody id="tradeData">
                    <tr>
                        <td colspan="10" style="text-align: center; padding: 40px;">æ­£åœ¨åŠ è½½äº¤æ˜“æ•°æ®...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="disclaimer-footer">
            <p>ç‰¹æ–¯æ‹‰(TSLA)æ¨¡æ‹Ÿäº¤æ˜“ç­–ç•¥è·Ÿè¸ª &copy; 2026</p>
            <p><strong>é£é™©æç¤ºï¼š</strong>æ‰€æœ‰å±•ç¤ºçš„æ•°æ®å’Œå›¾è¡¨ä»…ä¸ºå†å²å›æµ‹ç»“æœï¼Œä¸æ¶‰åŠçœŸå®èµ„é‡‘ï¼Œä¸æ„æˆä»»ä½•å½¢å¼çš„æŠ•èµ„å»ºè®®æˆ–æ‰¿è¯ºã€‚æœ¬ç½‘é¡µå¼€å‘è€…ã€å‘å¸ƒè€…ä¸å¯¹å› ä½¿ç”¨æˆ–å‚è€ƒæ­¤å†…å®¹è€Œå¯¼è‡´çš„ä»»ä½•æŠ•èµ„æŸå¤±æ‰¿æ‹…è´£ä»»ã€‚å¹³å°æ•°æ®æ¥æºäºå…¬å¼€å¸‚åœºä¿¡æ¯ï¼Œä¸ä¿è¯å‡†ç¡®æ€§ã€å®Œæ•´æ€§æˆ–åŠæ—¶æ€§ã€‚æŠ•èµ„æœ‰é£é™©ï¼Œè¯·æ‚¨åœ¨åšå‡ºä»»ä½•å†³ç­–å‰ï¼ŒåŠ¡å¿…å®¡æ…è¯„ä¼°è‡ªèº«çš„é£é™©æ‰¿å—èƒ½åŠ›ã€‚å¸Œæœ›è¿™ä»½è®°å½•èƒ½æˆä¸ºæ‚¨æ€è€ƒçš„è¾…åŠ©ï¼Œè€Œéè¡ŒåŠ¨çš„æŒ‡ä»¤ã€‚</p>
        </div>
    </div>

    <div id="disclaimerModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeDisclaimerModal()">âœ•</button>
            <h3 class="modal-title"><i class="fas fa-exclamation-triangle"></i> å…è´£å£°æ˜</h3>
            <div class="modal-body">
                <p><strong>1. æ€§è´¨è¯´æ˜</strong> æ‰€æœ‰å±•ç¤ºçš„æ•°æ®å’Œå›¾è¡¨ä»…ä¸ºå†å²å›æµ‹ç»“æœï¼Œä¸æ¶‰åŠçœŸå®èµ„é‡‘ï¼Œä¸æ„æˆä»»ä½•å½¢å¼çš„æŠ•èµ„å»ºè®®æˆ–æ‰¿è¯ºã€‚</p>
                <p><strong>2. æ•°æ®è¯´æ˜</strong> å¹³å°æ•°æ®æ¥æºäºå…¬å¼€å¸‚åœºä¿¡æ¯ï¼Œä¸ä¿è¯å‡†ç¡®æ€§ã€å®Œæ•´æ€§æˆ–åŠæ—¶æ€§ã€‚</p>
                <p><strong>3. å…è´£å£°æ˜</strong> æœ¬ç½‘é¡µå¼€å‘è€…ã€å‘å¸ƒè€…ä¸å¯¹å› ä½¿ç”¨æˆ–å‚è€ƒæ­¤å†…å®¹è€Œå¯¼è‡´çš„ä»»ä½•æŠ•èµ„æŸå¤±æ‰¿æ‹…è´£ä»»ã€‚</p>
                <p><strong>4. é£é™©æç¤º</strong> æŠ•èµ„æœ‰é£é™©ï¼Œè¯·æ‚¨åœ¨åšå‡ºä»»ä½•å†³ç­–å‰ï¼ŒåŠ¡å¿…å®¡æ…è¯„ä¼°è‡ªèº«çš„é£é™©æ‰¿å—èƒ½åŠ›ã€‚</p>
                <p><strong>5. æ­£ç¡®èµ·ç‚¹</strong> å¸Œæœ›è¿™ä»½è®°å½•èƒ½æˆä¸ºæ‚¨æ€è€ƒçš„è¾…åŠ©ï¼Œè€Œéè¡ŒåŠ¨çš„æŒ‡ä»¤ã€‚</p>
            </div>
        </div>
    </div>

    <script>
        // ========== Kçº¿é…ç½®å‚æ•° ==========
        const KLINE_CONFIG = {
            // åŸºå‡†è®¾ç½®
            BASE_SCREEN_WIDTH: 2560,      // CSSåƒç´ å®½åº¦
            BASE_COUNT: 100,              // åŸºå‡†Kçº¿æ•°é‡
            BASE_PIXEL_WIDTH: 9,          // åŸºå‡†åƒç´ å®½åº¦ï¼ˆ100æ ¹Kçº¿æ—¶ï¼‰

            // è¾¹ç•Œé™åˆ¶
            MIN_PIXEL_WIDTH: 1,           // æœ€å°åƒç´ å®½åº¦
            MAX_PIXEL_WIDTH: 40,          // æœ€å¤§åƒç´ å®½åº¦

            // é—´è·é…ç½®
            GAP_RATIO: 1.0,               // é—´è·å å®½åº¦çš„æ¯”ä¾‹ï¼ˆ1.0è¡¨ç¤ºé—´è·=å®½åº¦ï¼‰
            MIN_GAP_RATIO: 0.2,           // æœ€å°é—´è·æ¯”ä¾‹
            MAX_GAP_RATIO: 1.0,           // æœ€å¤§é—´è·æ¯”ä¾‹

            // æ ‡è®°ç‚¹é…ç½®
            MARKER_SIZE_RATIO: 0.8,       // æ ‡è®°ç‚¹å¤§å°ä¸Kçº¿å®½åº¦çš„æ¯”ä¾‹
            MIN_MARKER_SIZE: 1,           // æœ€å°æ ‡è®°ç‚¹å¤§å°
            MAX_MARKER_SIZE: 32,          // æœ€å¤§æ ‡è®°ç‚¹å¤§å°

            // ç¼©æ”¾å“åº”å‚æ•°
            SCALE_FACTOR_MULTIPLIER: 1.0, // æ•´ä½“ç¼©æ”¾å€æ•°

            // å®½åº¦åˆ†æ®µé…ç½®
            WIDTH_SEGMENTS: [
                { maxCount: 20, width: 19 },     // 20æ ¹ä»¥å†…ï¼Œ19åƒç´ 
                { maxCount: 40, width: 17 },
                { maxCount: 60, width: 15 },
                { maxCount: 80, width: 13 },
                { maxCount: 100, width: 11 },
                { maxCount: 150, width: 9 },
                { maxCount: 200, width: 7 },
                { maxCount: 300, width: 5 },
                { maxCount: 500, width: 3 },
                { maxCount: Infinity, width: 1 } // 500æ ¹ä»¥ä¸Šï¼Œ1åƒç´ 
            ],

            // é—´è·åˆ†æ®µé…ç½®
            GAP_SEGMENTS: [
                { maxCount: 50, gapRatio: 0.8 },   // 20æ ¹ä»¥å†…ï¼Œé—´è·=0.8å€å®½åº¦
                { maxCount: 100, gapRatio: 0.6 },
                { maxCount: 200, gapRatio: 0.4 },
                { maxCount: Infinity, gapRatio: 0.2 } // 200æ ¹ä»¥ä¸Šï¼Œé—´è·=0.2å€å®½åº¦
            ]
        };

        let chartInstance = null;
        let currentData = null;
        let dataVersion = "1.0.0";
        let isSliding = false; // é˜²æ­¢é‡å¤æ»šåŠ¨çš„æ ‡å¿—
        let slideCooldown = false; // å†·å´æ ‡å¿—
        let lastWheelTime = 0; // ä¸Šæ¬¡æ»šè½®äº‹ä»¶æ—¶é—´
        let wheelSpeedFactor = 0; // æ»šè½®é€Ÿåº¦å› å­
        let cumulativeDelta = 0; // ç´¯ç§¯çš„æ»šåŠ¨é‡
        let lastUpdateTime = 0; // ä¸Šæ¬¡æ›´æ–°æ—¶é—´
        let currentKlineCount = 100; // å½“å‰é»˜è®¤æ˜¾ç¤ºçš„Kçº¿æ•°é‡

        // å…è´£å£°æ˜ç›¸å…³
        function showDisclaimerModal() {
            document.getElementById('disclaimerModal').style.display = 'block';
        }

        function closeDisclaimerModal() {
            document.getElementById('disclaimerModal').style.display = 'none';
            document.cookie = "disclaimer_closed=true; max-age=86400; path=/";
        }

        function checkDisclaimer() {
            if (!document.cookie.includes('disclaimer_closed=true')) {
                setTimeout(() => {
                    document.getElementById('disclaimerModal').style.display = 'block';
                }, 1000);
            }
        }

        // è·å–æ•°æ®æ–‡ä»¶URL
        const getDataFileUrl = () => {
            return `./data.json?t=${Date.now()}`;
        };

        // æ˜¾ç¤º/éšè—åŠ è½½æŒ‡ç¤ºå™¨
        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.style.display = show ? 'flex' : 'none';
            }
        }

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.innerHTML = `
                <h3><i class="fas fa-exclamation-triangle"></i> åŠ è½½æ•°æ®å¤±è´¥</h3>
                <p>${message}</p>
                <button onclick="location.reload()">åˆ·æ–°é¡µé¢</button>
            `;
            document.body.appendChild(errorDiv);
            showLoading(false);
        }

        // åŠ è½½JSONæ•°æ®
        async function loadJSON(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return await response.json();
            } catch (error) {
                console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
                throw error;
            }
        }

        // ä»tradesæ•°æ®ç”ŸæˆKçº¿æ•°æ®
        function generateKlineFromTrades(trades) {
            if (!trades || trades.length === 0) {
                return [];
            }

            const sortedTrades = [...trades].sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
            });

            return sortedTrades.map(trade => {
                const dateStr = trade.date;
                let formattedDate = dateStr;

                if (dateStr && dateStr.length === 15) {
                    try {
                        const datePart = dateStr.substring(0, 8);
                        const timePart = dateStr.substring(9);
                        const year = datePart.substring(0, 4);
                        const month = datePart.substring(4, 6);
                        const day = datePart.substring(6, 8);
                        formattedDate = `${year}-${month}-${day} ${timePart}`;
                    } catch (e) {
                        console.error('æ—¥æœŸæ ¼å¼åŒ–é”™è¯¯:', e);
                    }
                }

                return [
                    formattedDate,
                    Number(trade.open) || 0,
                    Number(trade.high) || 0,
                    Number(trade.low) || 0,
                    Number(trade.close) || 0
                ];
            });
        }

        // ä»tradesæ•°æ®ç”Ÿæˆå‡€å€¼æ•°æ®
        function generateEquityData(trades) {
            if (!trades || trades.length === 0) {
                return [];
            }

            const sortedTrades = [...trades].sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
            });

            return sortedTrades.map(trade => {
                const dateStr = trade.date;
                let formattedDate = dateStr;

                if (dateStr && dateStr.length === 15) {
                    try {
                        const datePart = dateStr.substring(0, 8);
                        const timePart = dateStr.substring(9);
                        const year = datePart.substring(0, 4);
                        const month = datePart.substring(4, 6);
                        const day = datePart.substring(6, 8);
                        formattedDate = `${year}-${month}-${day} ${timePart}`;
                    } catch (e) {
                        console.error('æ—¥æœŸæ ¼å¼åŒ–é”™è¯¯:', e);
                    }
                }

                return [
                    formattedDate,
                    Number(trade.equity) || 0
                ];
            });
        }

        // ä»tradesæ•°æ®ç”Ÿæˆæ¯æ—¥ç»“æŸæ—¶çš„å‡€å€¼æ•°æ®
        function generateDailyEquityData(trades) {
            if (!trades || trades.length === 0) {
                return [];
            }

            const sortedTrades = [...trades].sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
            });

            const dailyEquityMap = new Map();

            sortedTrades.forEach(trade => {
                const dateStr = trade.date;
                let dateKey = '';

                if (dateStr) {
                    if (dateStr.length === 15) {
                        try {
                            const datePart = dateStr.substring(0, 8);
                            const year = datePart.substring(0, 4);
                            const month = datePart.substring(4, 6);
                            const day = datePart.substring(6, 8);
                            dateKey = `${year}-${month}-${day}`;
                        } catch (e) {
                            console.error('æ—¥æœŸæ ¼å¼åŒ–é”™è¯¯:', e);
                        }
                    } else if (dateStr.length >= 10) {
                        try {
                            dateKey = dateStr.substring(0, 10);
                        } catch (e) {
                            console.error('æ—¥æœŸæ ¼å¼åŒ–é”™è¯¯:', e);
                        }
                    }
                }

                if (dateKey) {
                    dailyEquityMap.set(dateKey, {
                        date: dateKey,
                        equity: Number(trade.equity) || 0
                    });
                }
            });

            return Array.from(dailyEquityMap.values())
                .sort((a, b) => a.date.localeCompare(b.date))
                .map(item => [item.date, item.equity]);
        }

        // ä»å‡€å€¼æ•°æ®ç”Ÿæˆæ”¶ç›Šç™¾åˆ†æ¯”æ•°æ®
        function generateReturnsFromEquity(equityData) {
            if (!equityData || equityData.length === 0) {
                return [];
            }

            const initialEquity = equityData[0][1];
            if (initialEquity <= 0) {
                return [];
            }

            return equityData.map(item => {
                const currentEquity = item[1];
                const returnPercent = ((currentEquity - initialEquity) / initialEquity * 100);
                return [
                    item[0],
                    parseFloat(returnPercent.toFixed(2))
                ];
            });
        }

        // è®¡ç®—æœ€å¤§å›æ’¤
        function calculateMaxDrawdownFromEquity(dailyEquityData) {
            if (!dailyEquityData || dailyEquityData.length < 2) {
                return { maxDrawdownPercent: 0, maxDrawdownDays: 0 };
            }

            let peak = dailyEquityData[0][1];
            let maxDrawdown = 0;
            let peakDate = dailyEquityData[0][0];
            let drawdownStartDate = dailyEquityData[0][0];
            let drawdownEndDate = dailyEquityData[0][0];

            for (let i = 1; i < dailyEquityData.length; i++) {
                const currentEquity = dailyEquityData[i][1];
                const currentDate = dailyEquityData[i][0];

                if (currentEquity > peak) {
                    peak = currentEquity;
                    peakDate = currentDate;
                } else {
                    const drawdown = (peak - currentEquity) / peak * 100;
                    if (drawdown > maxDrawdown) {
                        maxDrawdown = drawdown;
                        drawdownStartDate = peakDate;
                        drawdownEndDate = currentDate;
                    }
                }
            }

            let maxDrawdownDays = 0;
            try {
                const startDate = new Date(drawdownStartDate);
                const endDate = new Date(drawdownEndDate);
                const timeDiff = Math.abs(endDate.getTime() - startDate.getTime());
                maxDrawdownDays = Math.ceil(timeDiff / (1000 * 3600 * 24));
                if (isNaN(maxDrawdownDays) || maxDrawdownDays < 0) {
                    maxDrawdownDays = 0;
                }
            } catch (e) {
                console.error('è®¡ç®—æœ€å¤§å›æ’¤å¤©æ•°é”™è¯¯:', e);
                maxDrawdownDays = 0;
            }

            return {
                maxDrawdownPercent: maxDrawdown.toFixed(2),
                maxDrawdownDays: maxDrawdownDays
            };
        }

        // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
        function formatDate(dateStr) {
            if (!dateStr) return '';
            try {
                if (dateStr.length === 15) {
                    const datePart = dateStr.substring(0, 8);
                    const timePart = dateStr.substring(9);
                    const year = datePart.substring(0, 4);
                    const month = datePart.substring(4, 6);
                    const day = datePart.substring(6, 8);
                    return `${year}-${month}-${day} ${timePart}`;
                } else if (dateStr.length === 19) {
                    return dateStr;
                } else if (dateStr.includes('-')) {
                    return dateStr;
                } else {
                    console.warn('æœªçŸ¥æ—¥æœŸæ ¼å¼:', dateStr);
                    return dateStr;
                }
            } catch (e) {
                console.error('æ—¥æœŸæ ¼å¼åŒ–é”™è¯¯:', e, 'åŸå§‹å­—ç¬¦ä¸²:', dateStr);
                return dateStr;
            }
        }

        // ç”Ÿæˆä¹°å–æ ‡è®°æ•°æ®
        function generateTradeMarkers(tradeRecords) {
            if (!tradeRecords || tradeRecords.length === 0) {
                return { buyMarkers: [], sellMarkers: [] };
            }

            const sortedTrades = [...tradeRecords].sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
            });

            const buyMarkers = [];
            const sellMarkers = [];

            sortedTrades.forEach(trade => {
                const dateStr = trade.date;
                let formattedDate = dateStr;

                if (dateStr && dateStr.length === 15) {
                    try {
                        const datePart = dateStr.substring(0, 8);
                        const timePart = dateStr.substring(9);
                        const year = datePart.substring(0, 4);
                        const month = datePart.substring(4, 6);
                        const day = datePart.substring(6, 8);
                        formattedDate = `${year}-${month}-${day} ${timePart}`;
                    } catch (e) {
                        console.error('æ—¥æœŸæ ¼å¼åŒ–é”™è¯¯:', e);
                    }
                }

                const closePrice = Number(trade.close) || 0;
                const lowPrice = Number(trade.low) || closePrice;
                const highPrice = Number(trade.high) || closePrice;

                if (trade.operation === 'BUY') {
                    const buyPosition = lowPrice - (lowPrice * 0.002);
                    buyMarkers.push({
                        value: [
                            formattedDate,
                            buyPosition,
                            'BUY',
                            'BUY',
                            closePrice.toFixed(2)
                        ]
                    });
                } else if (trade.operation === 'SELL') {
                    const sellPosition = highPrice + (highPrice * 0.002);
                    sellMarkers.push({
                        value: [
                            formattedDate,
                            sellPosition,
                            'SELL',
                            'SELL',
                            closePrice.toFixed(2)
                        ]
                    });
                }
            });

            console.log('ä¹°å…¥æ ‡è®°æ•°é‡:', buyMarkers.length);
            console.log('å–å‡ºæ ‡è®°æ•°é‡:', sellMarkers.length);

            return { buyMarkers, sellMarkers };
        }

        // ========== Kçº¿å®½åº¦è®¡ç®—å‡½æ•° ==========

        // è®¡ç®—Kçº¿åƒç´ å®½åº¦
        function calculatePixelWidth(visibleCount, chartWidth) {
            const config = KLINE_CONFIG;

            // å±å¹•ç¼©æ”¾å› å­
            const scaleFactor = chartWidth / config.BASE_SCREEN_WIDTH;

            // æ ¹æ®å¯è§Kçº¿æ•°é‡æŸ¥æ‰¾å¯¹åº”çš„å®½åº¦é…ç½®
            for (const segment of config.WIDTH_SEGMENTS) {
                if (visibleCount <= segment.maxCount) {
                    // åŸºç¡€åƒç´ å®½åº¦
                    let pixelWidth = segment.width;

                    // åº”ç”¨å±å¹•ç¼©æ”¾
                    pixelWidth *= scaleFactor;

                    // åº”ç”¨æ•´ä½“ç¼©æ”¾å€æ•°
                    pixelWidth *= config.SCALE_FACTOR_MULTIPLIER;

                    // è¾¹ç•Œé™åˆ¶
                    pixelWidth = Math.max(
                        config.MIN_PIXEL_WIDTH,
                        Math.min(config.MAX_PIXEL_WIDTH, pixelWidth)
                    );

                    return pixelWidth;
                }
            }

            // é»˜è®¤è¿”å›æœ€å°å®½åº¦
            return config.MIN_PIXEL_WIDTH;
        }

        // è®¡ç®—é—´è·æ¯”ä¾‹
        function calculateGapRatio(visibleCount) {
            const config = KLINE_CONFIG;

            // æ ¹æ®å¯è§Kçº¿æ•°é‡æŸ¥æ‰¾å¯¹åº”çš„é—´è·é…ç½®
            for (const segment of config.GAP_SEGMENTS) {
                if (visibleCount <= segment.maxCount) {
                    return Math.max(
                        config.MIN_GAP_RATIO,
                        Math.min(config.MAX_GAP_RATIO, segment.gapRatio)
                    );
                }
            }

            // é»˜è®¤è¿”å›åŸºç¡€é—´è·æ¯”ä¾‹
            return config.GAP_RATIO;
        }

        // è®¡ç®—æ ‡è®°ç‚¹å¤§å°
        function calculateMarkerSize(klineWidth) {
            const config = KLINE_CONFIG;

            // æ ¹æ®Kçº¿å®½åº¦è®¡ç®—æ ‡è®°ç‚¹å¤§å°
            let markerSize = klineWidth * config.MARKER_SIZE_RATIO;

            // è¾¹ç•Œé™åˆ¶
            markerSize = Math.max(
                config.MIN_MARKER_SIZE,
                Math.min(config.MAX_MARKER_SIZE, markerSize)
            );

            return markerSize;
        }

        // è®¡ç®—å¹¶æ›´æ–°Kçº¿å®½åº¦
        function updateBarWidth() {
            if (!chartInstance) return;

            const option = chartInstance.getOption();
            if (!option.dataZoom || option.dataZoom.length < 2) return;

            const dataZoom = option.dataZoom[1]; // ä½¿ç”¨sliderçš„dataZoom
            const xAxisData = option.xAxis[0].data || [];
            const dataLength = xAxisData.length;

            if (dataLength === 0) return;

            // è·å–å½“å‰æ˜¾ç¤ºçš„Kçº¿æ•°é‡
            const startPercent = dataZoom.start || 0;
            const endPercent = dataZoom.end || 100;
            const visibleCount = Math.round((endPercent - startPercent) / 100 * dataLength);

            if (visibleCount <= 0) return;

            // è·å–å›¾è¡¨å®¹å™¨å®é™…å®½åº¦
            const chartWidth = chartInstance.getWidth();

            if (!chartWidth || chartWidth <= 0) {
                console.warn('æ— æ³•è·å–å›¾è¡¨å®½åº¦ï¼Œå»¶è¿Ÿé‡è¯•...');
                setTimeout(updateBarWidth, 100);
                return;
            }

            // 1. è®¡ç®—Kçº¿åƒç´ å®½åº¦
            let pixelWidth = calculatePixelWidth(visibleCount, chartWidth);

            // 2. è®¡ç®—é—´è·æ¯”ä¾‹
            let gapRatio = calculateGapRatio(visibleCount);

            // 3. è®¡ç®—é—´è·åƒç´ å€¼
            const gapPixels = pixelWidth * gapRatio;

            // 4. è®¡ç®—æ¯ä¸ªKçº¿åœ¨xè½´ä¸Šçš„æ€»è·¨åº¦ï¼ˆKçº¿å®½åº¦+é—´è·ï¼‰
            const totalSpanPerKline = pixelWidth + gapPixels;

            // 5. è®¡ç®—xè½´æœ‰æ•ˆå®½åº¦ï¼ˆå‡å»å·¦å³è¾¹è·ï¼‰
            const xAxisRange = chartWidth * 0.93; // gridå·¦å³è¾¹è·åˆ†åˆ«ä¸º3%å’Œ4%

            // 6. è®¡ç®—Kçº¿æ•°é‡æ˜¯å¦é€‚åˆå½“å‰å®½åº¦
            const requiredWidth = visibleCount * totalSpanPerKline;

            if (requiredWidth > xAxisRange) {
                // å¦‚æœæ€»å®½åº¦è¶…è¿‡æœ‰æ•ˆå®½åº¦ï¼ŒæŒ‰æ¯”ä¾‹ç¼©å°
                const scaleFactor = xAxisRange / requiredWidth;
                pixelWidth *= scaleFactor;
                gapRatio *= scaleFactor;
            }

            // 7. è¾¹ç•Œæ£€æŸ¥
            pixelWidth = Math.max(
                KLINE_CONFIG.MIN_PIXEL_WIDTH,
                Math.min(KLINE_CONFIG.MAX_PIXEL_WIDTH, pixelWidth)
            );

            // 8. è®¡ç®—ç™¾åˆ†æ¯”å®½åº¦å’Œé—´è·
            const klineSpan = xAxisRange / Math.max(visibleCount, 1);
            const barWidthPercent = (pixelWidth / klineSpan) * 100;
            const gapPercent = (pixelWidth * gapRatio / klineSpan) * 100;

            // 9. è®¡ç®—æ ‡è®°ç‚¹å¤§å°
            const markerSize = calculateMarkerSize(pixelWidth);

            console.log(
                `ğŸ“Š Kçº¿é…ç½®: æ•°é‡=${visibleCount}, ` +
                `å®½åº¦=${pixelWidth.toFixed(1)}px, ` +
                `é—´è·=${gapRatio.toFixed(1)}å€, ` +
                `æ ‡è®°ç‚¹=${markerSize.toFixed(1)}px`
            );

            // 10. æ›´æ–°å›¾è¡¨é€‰é¡¹ - åªæ›´æ–°Kçº¿ç³»åˆ—
            const currentOption = chartInstance.getOption();
            const newOption = {
                series: [
                    {
                        type: 'candlestick',
                        barWidth: barWidthPercent + '%',
                        barCategoryGap: gapPercent + '%',
                        barMinWidth: 1,
                        barMaxWidth: 100
                    },
                    // ä¿æŒæ”¶ç›Šçº¿ä¸å˜
                    currentOption.series[1],
                    {
                        type: 'scatter',
                        symbolSize: markerSize
                    },
                    {
                        type: 'scatter',
                        symbolSize: markerSize
                    }
                ]
            };

            chartInstance.setOption(newOption, false, true);
        }

        // åˆå§‹åŒ–åˆå¹¶å›¾è¡¨
        function initCombinedChart(klineData, returnsData, tradeRecords) {
            const chartDom = document.getElementById('combinedChart');
            if (!chartDom) {
                return null;
            }

            if (chartInstance) {
                chartInstance.dispose();
            }

            chartInstance = echarts.init(chartDom);

            if (!klineData || klineData.length === 0) {
                chartDom.innerHTML = '<div style="color: #aaa; text-align: center; padding: 50px;">æš‚æ— å›¾è¡¨æ•°æ®</div>';
                return null;
            }

            const klineSeriesData = klineData.map(item => [
                item[1] || 0,
                item[4] || 0,
                item[3] || 0,
                item[2] || 0
            ]);

            const timeData = klineData.map(item => item[0] || '');

            let returnsSeriesData = [];
            if (returnsData && returnsData.length > 0) {
                returnsSeriesData = returnsData.map(item => item[1] || 0);
            }

            const tradeMarkers = generateTradeMarkers(tradeRecords);

            const option = {
                backgroundColor: 'transparent',
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    textStyle: { color: '#fff' },
                    formatter: function(params) {
                        let result = '';
                        let operationType = '';
                        let markerData = null;

                        params.forEach(param => {
                            if (param.seriesType === 'candlestick') {
                                const dataIndex = param.dataIndex;
                                result += `<strong>${timeData[dataIndex]}</strong><br/>`;
                                result += `å¼€ç›˜: ${param.value[1]}<br/>`;
                                result += `æœ€é«˜: ${param.value[4]}<br/>`;
                                result += `æœ€ä½: ${param.value[3]}<br/>`;
                                result += `æ”¶ç›˜: ${param.value[2]}<br/>`;
                            } else if (param.seriesType === 'line') {
                                result += `æ”¶ç›Š: ${param.value.toFixed(2)}%<br/>`;
                            } else if (param.seriesType === 'scatter') {
                                if (param.data && param.data.length > 2) {
                                    markerData = param.data;
                                }
                            }
                        });

                        if (markerData) {
                            operationType = markerData[2] || markerData[3] || '';
                        }

                        if (operationType === 'BUY' || operationType === 'SELL') {
                            result += `æ“ä½œ: ${operationType}<br/>`;
                        }

                        return result;
                    }
                },
                legend: {
                    data: ['ä»·æ ¼', 'æ”¶ç›Š', 'ä¹°å…¥', 'å–å‡º'],
                    textStyle: { color: '#aaa' },
                    top: 10,
                },
                dataZoom: [
                    {
                        type: 'inside',
                        xAxisIndex: 0,
                        filterMode: 'filter',
                        zoomOnMouseWheel: true,  // å›¾è¡¨åŒºåŸŸå†…æ»šè½®ç¼©æ”¾
                        moveOnMouseWheel: true,  // å›¾è¡¨åŒºåŸŸå†…æ»šè½®å¹³ç§» - ç¦ç”¨ï¼Œç”¨è‡ªå®šä¹‰
                        moveOnMouseMove: true,    // å›¾è¡¨åŒºåŸŸå†…é¼ æ ‡æ‹–æ‹½å¹³ç§»
                        zoomLock: true,          // ç¦ç”¨ç¼©æ”¾
                        zoomSensitivity: 0.5,     // ç¼©æ”¾çµæ•åº¦ï¼Œå€¼è¶Šå°è¶Šæ…¢
                        start: Math.max(0, 100 - Math.min(currentKlineCount, klineData.length) / klineData.length * 100),
                        end: 100,
                        minValueSpan: Math.min(20, klineData.length),
                        maxValueSpan: Math.min(2000000, klineData.length)
                    },
                    {
                        type: 'slider',
                        xAxisIndex: 0,
                        show: true,
                        start: Math.max(0, 100 - Math.min(currentKlineCount, klineData.length) / klineData.length * 100),
                        end: 100,
                        bottom: 15, // æ§åˆ¶ç‚¹1ï¼šæ»‘å—è·ç¦»å®¹å™¨åº•éƒ¨çš„è·ç¦»ï¼ˆåƒç´ å€¼ï¼‰ï¼Œå€¼è¶Šå¤§æ»‘å—è¶Šé ä¸Š
                        height: 20, // æ»‘å—æ¡çš„é«˜åº¦
                        backgroundColor: 'rgba(150, 150, 150, 0.2)',
                        borderColor: 'rgba(150, 150, 150, 0.3)',
                        fillerColor: 'rgba(150, 150, 150, 1.0)',
                        handleStyle: {
                            color: 'rgba(240, 240, 240, 1.0)',
                            borderColor: 'rgba(240, 240, 240, 1.0)',
                            borderWidth: 1
                        },
                        textStyle: { color: '#aaa' },
                        dataBackground: {
                            lineStyle: { opacity: 0 },
                            areaStyle: { opacity: 0 }
                        },
                        // ç¦ç”¨EChartsè‡ªå¸¦çš„æ»šè½®æ§åˆ¶
                        moveOnMouseWheel: false,
                        zoomOnMouseWheel: false,
                        brushSelect: false,
                        showDetail: false
                    }
                ],
                grid: {
                    left: '3%',
                    right: '4%',
                    bottom: '15%', // æ§åˆ¶ç‚¹2ï¼šå›¾è¡¨åŒºåŸŸï¼ˆåŒ…æ‹¬Kçº¿ã€åæ ‡è½´ã€æ—¥æœŸæ ‡ç­¾ï¼‰è·ç¦»å®¹å™¨åº•éƒ¨çš„è·ç¦»ï¼ˆç™¾åˆ†æ¯”ï¼‰ï¼Œå€¼è¶Šå¤§å›¾è¡¨è¶Šé ä¸Š
                    top: '10%'    // å›¾è¡¨åŒºåŸŸè·ç¦»å®¹å™¨é¡¶éƒ¨çš„è·ç¦»
                },
                xAxis: {
                    type: 'category',
                    data: timeData,
                    axisLine: { lineStyle: { color: '#aaa' } },
                    axisLabel: {
                        color: '#aaa',
                        fontSize: 10,
                        formatter: function(value) {
                            if (!value) return '';
                            const parts = value.split(' ');
                            if (parts.length > 1) {
                                return parts[0];
                            }
                            return value;
                        },
                        margin: 8, // æ§åˆ¶ç‚¹3ï¼šæ—¥æœŸæ ‡ç­¾ä¸xè½´çº¿ä¹‹é—´çš„è·ç¦»
                    },
                    offset: 0, // æ§åˆ¶ç‚¹4ï¼šxè½´è·ç¦»å›¾è¡¨åŒºåŸŸåº•éƒ¨çš„è·ç¦»ï¼ˆå†…éƒ¨åç§»ï¼‰ï¼Œæ­£å€¼å‘ä¸‹åç§»ï¼Œè´Ÿå€¼å‘ä¸Šåç§»
                },
                yAxis: [
                    {
                        type: 'value',
                        scale: true,
                        // name: 'ä»·æ ¼',
                        nameTextStyle: { color: '#aaa' },
                        axisLine: { lineStyle: { color: '#aaa' } },
                        axisLabel: { color: '#aaa', formatter: '{value}' },
                        splitLine: {
                            lineStyle: {
                                color: 'rgba(255, 255, 255, 0.1)',
                                type: 'dashed'
                            }
                        }
                    },
                    {
                        type: 'value',
                        scale: true,
                        // name: 'æ”¶ç›Š(%)',
                        nameTextStyle: { color: '#aaa' },
                        axisLine: { lineStyle: { color: '#aaa' } },
                        axisLabel: { color: '#aaa', formatter: '{value}%' },
                        splitLine: { show: false },
                        position: 'right'
                    }
                ],
                series: [
                    {
                        name: 'ä»·æ ¼',
                        type: 'candlestick',
                        data: klineSeriesData,
                        itemStyle: {
                            color: '#ff3b30',
                            color0: '#4cd964',
                            borderColor: '#ff3b30',
                            borderColor0: '#4cd964',
                            borderWidth: 1
                        },
                        // åˆå§‹å®½åº¦è®¾ä¸ºè‡ªåŠ¨ï¼Œåç»­ä¼šç”±updateBarWidthæ›´æ–°
                        barWidth: 'auto',
                        barCategoryGap: '30%',
                        yAxisIndex: 0
                    },
                    {
                        name: 'æ”¶ç›Š',
                        type: 'line',
                        yAxisIndex: 1,
                        data: returnsSeriesData,
                        smooth: true,
                        symbol: 'none',
                        lineStyle: {
                            width: 2,
                            color: '#00c9ff'
                        },
                        itemStyle: {
                            color: '#00c9ff'
                        },
                        areaStyle: {
                            color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                { offset: 0, color: 'rgba(0, 201, 255, 0.5)' },
                                { offset: 1, color: 'rgba(0, 201, 255, 0.1)' }
                            ])
                        }
                    },
                    {
                        name: 'ä¹°å…¥',
                        type: 'scatter',
                        data: tradeMarkers.buyMarkers.map(marker => marker.value),
                        symbol: 'circle',
                        symbolSize: 6, // åˆå§‹å¤§å°ï¼Œä¼šè¢«updateBarWidthè¦†ç›–
                        symbolRotate: 0,
                        itemStyle: {
                            color: '#FFAAAA',
                            borderWidth: 0
                        },
                        yAxisIndex: 0,
                        zlevel: 20
                    },
                    {
                        name: 'å–å‡º',
                        type: 'scatter',
                        data: tradeMarkers.sellMarkers.map(marker => marker.value),
                        symbol: 'circle',
                        symbolSize: 6, // åˆå§‹å¤§å°ï¼Œä¼šè¢«updateBarWidthè¦†ç›–
                        symbolRotate: 0,
                        itemStyle: {
                            color: '#F0FFF0',
                            borderWidth: 0
                        },
                        yAxisIndex: 0,
                        zlevel: 20
                    }
                ]
            };

            chartInstance.setOption(option);

            // è‡ªå®šä¹‰æ»šè½®æ§åˆ¶é€»è¾‘
            setupCustomWheelControl(chartDom);

            // è®¡ç®—å¹¶åº”ç”¨åŠ¨æ€å®½åº¦
            updateBarWidth();

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', function() {
                chartInstance.resize();
                updateBarWidth();
            });

            // ç›‘å¬dataZoomå˜åŒ–
            chartInstance.on('dataZoom', function(params) {
                updateBarWidth();
            });

            return chartInstance;
        }

        // è®¾ç½®è‡ªå®šä¹‰æ»šè½®æ§åˆ¶
        function setupCustomWheelControl(chartDom) {
            const slider = chartDom.querySelector('.echarts-slider');
            if (!slider) {
                setTimeout(() => setupCustomWheelControl(chartDom), 100);
                return;
            }

            // ç¦ç”¨EChartsè‡ªå¸¦çš„æ»šè½®äº‹ä»¶
            chartDom.removeEventListener('wheel', chartDom._wheelHandler);

            // æ·»åŠ è‡ªå®šä¹‰æ»šè½®äº‹ä»¶ç›‘å¬
            slider.addEventListener('wheel', handleCustomWheel, { passive: false });

            // è®°å½•æ»šè½®å¤„ç†å™¨ä»¥ä¾¿åç»­ç§»é™¤
            chartDom._customWheelHandler = handleCustomWheel;
        }

        // è‡ªå®šä¹‰æ»šè½®å¤„ç†å‡½æ•°
        function handleCustomWheel(e) {
            e.preventDefault();
            e.stopPropagation();

            if (isSliding) return;

            const currentTime = Date.now();
            const timeDiff = currentTime - lastWheelTime;

            // æ§åˆ¶æ»šè½®äº‹ä»¶é¢‘ç‡
            if (timeDiff < 50) { // 50æ¯«ç§’å†·å´æ—¶é—´ï¼Œå¯è°ƒæ•´
                return;
            }

            lastWheelTime = currentTime;

            // è·å–å½“å‰dataZoomçš„startå’Œend
            const currentOption = chartInstance.getOption();
            const dataZoom = currentOption.dataZoom[1];

            if (!dataZoom || dataZoom.start === undefined || dataZoom.end === undefined) {
                return;
            }

            // è®¡ç®—æ»šè½®æ»šåŠ¨é‡ - ä½¿ç”¨æ›´çµæ•çš„ç®—æ³•
            let delta = 0;
            if (e.deltaMode === 0) { // åƒç´ æ¨¡å¼
                delta = e.deltaY * 0.001; // ç¼©æ”¾å› å­ï¼Œå¯è°ƒæ•´
            } else if (e.deltaMode === 1) { // è¡Œæ¨¡å¼
                delta = e.deltaY * 0.003; // ç¼©æ”¾å› å­ï¼Œå¯è°ƒæ•´
            } else { // é¡µé¢æ¨¡å¼
                delta = e.deltaY * 0.0010; // ç¼©æ”¾å› å­ï¼Œå¯è°ƒæ•´
            }

            // è®¡ç®—æ–°çš„startå’Œend
            let newStart = dataZoom.start - delta;
            let newEnd = dataZoom.end - delta;

            // è¾¹ç•Œæ£€æŸ¥ - é˜²æ­¢è¶…å‡ºèŒƒå›´
            if (newStart < 0) {
                newStart = 0;
                newEnd = Math.min(100, newEnd - newStart);
            }

            if (newEnd > 100) {
                newEnd = 100;
                newStart = Math.max(0, newStart - (newEnd - 100));
            }

            // ç¡®ä¿startå°äºend
            if (newStart >= newEnd) {
                if (delta > 0) {
                    newStart = newEnd - 1;
                } else {
                    newEnd = newStart + 1;
                }
            }

            // ç¡®ä¿èŒƒå›´åœ¨0-100ä¹‹é—´
            newStart = Math.max(0, Math.min(100, newStart));
            newEnd = Math.max(0, Math.min(100, newEnd));

            isSliding = true;

            // æ›´æ–°dataZoom
            chartInstance.dispatchAction({
                type: 'dataZoom',
                start: newStart,
                end: newEnd,
                dataZoomIndex: 1
            });

            // é‡ç½®æ»‘åŠ¨æ ‡å¿—
            setTimeout(() => {
                isSliding = false;
            }, 50);
        }

        // æ¸²æŸ“äº¤æ˜“è®°å½•è¡¨æ ¼
        function renderTradeTable(tradeRecords) {
            const tableBody = document.getElementById('tradeData');
            if (!tableBody) return;

            tableBody.innerHTML = '';

            if (!tradeRecords || tradeRecords.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="10" style="text-align: center;">æš‚æ— äº¤æ˜“æ•°æ®</td></tr>';
                return;
            }

            // å…ˆæŒ‰æ—¶é—´ä»æ—©åˆ°æ™šæ’åº
            const timeSortedTrades = [...tradeRecords].sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
            });

            // è¿‡æ»¤é‡å¤é¡¹ï¼šä»¥æ“ä½œ(operation)å’ŒæŒä»“(position)ä¸ºå‡†
            const uniqueRecords = [];

            for (let i = 0; i < timeSortedTrades.length; i++) {
                const currentRecord = timeSortedTrades[i];

                // å¦‚æœæ˜¯ç¬¬ä¸€æ¡è®°å½•ï¼Œæ€»æ˜¯æ·»åŠ 
                if (i === 0) {
                    uniqueRecords.push(currentRecord);
                    continue;
                }

                const prevRecord = timeSortedTrades[i - 1];

                // å¦‚æœæ“ä½œæˆ–ä»“ä½æœ‰å˜åŒ–ï¼Œæ·»åŠ åˆ°ç»“æœä¸­
                if (currentRecord.operation !== prevRecord.operation ||
                    currentRecord.position !== prevRecord.position) {
                    uniqueRecords.push(currentRecord);
                }
            }

            // æŒ‰æ—¥æœŸé™åºæ’åˆ—ç”¨äºæ˜¾ç¤ºï¼ˆæœ€æ–°çš„åœ¨æœ€ä¸Šé¢ï¼‰
            const displayRecords = [...uniqueRecords].sort((a, b) => {
                return new Date(b.date) - new Date(a.date);
            });

            displayRecords.forEach(record => {
                const row = document.createElement('tr');
                const operationClass = record.operation === 'BUY' ? 'buy-operation' : 'sell-operation';

                row.innerHTML = `
                    <td>${formatDate(record.date)}</td>
                    <td>${record.open !== undefined ? Number(record.open).toFixed(2) : '-'}</td>
                    <td>${record.high !== undefined ? Number(record.high).toFixed(2) : '-'}</td>
                    <td>${record.low !== undefined ? Number(record.low).toFixed(2) : '-'}</td>
                    <td>${record.close !== undefined ? Number(record.close).toFixed(2) : '-'}</td>
                    <td><span class="${operationClass}">${record.operation || '-'}</span></td>
                    <td>${record.strategy || '-'}</td>
                    <td>${record.position !== undefined ? record.position : '-'}</td>
                    <td>${record.price !== undefined ? Number(record.price).toFixed(2) : '-'}</td>
                    <td>${record.equity !== undefined ? Number(record.equity).toFixed(2) : '-'}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        // æ›´æ–°ç»Ÿè®¡æ•°æ®
        function updateStats(tradeRecords, equityData, dailyEquityData) {
            if (!tradeRecords || tradeRecords.length === 0) {
                ['totalPnl', 'maxDrawdown', 'maxDrawdownDays', 'totalPositions', 'tradeCount'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = '-';
                });
                return;
            }

            const sortedTrades = [...tradeRecords].sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
            });

            const firstRecord = sortedTrades[0];
            const latestRecord = sortedTrades[sortedTrades.length - 1];

            if (firstRecord.equity !== undefined && latestRecord.equity !== undefined) {
                const pnlEl = document.getElementById('totalPnl');
                if (pnlEl) {
                    const initialEquity = Number(firstRecord.equity);
                    const latestEquity = Number(latestRecord.equity);
                    if (initialEquity > 0) {
                        const totalReturn = ((latestEquity - initialEquity) / initialEquity * 100);
                        pnlEl.textContent = totalReturn.toFixed(2) + '%';
                    } else {
                        pnlEl.textContent = '0.00%';
                    }
                }
            }

            if (latestRecord.position !== undefined) {
                const positionsEl = document.getElementById('totalPositions');
                if (positionsEl) {
                    positionsEl.textContent = latestRecord.position.toString();
                }
            }

            const tradeCountEl = document.getElementById('tradeCount');
            if (tradeCountEl) {
                const uniqueRecords = [];
                const timeSortedTrades = [...tradeRecords].sort((a, b) => {
                    return new Date(a.date) - new Date(b.date);
                });

                for (let i = 0; i < timeSortedTrades.length; i++) {
                    const currentRecord = timeSortedTrades[i];
                    if (i === 0) {
                        uniqueRecords.push(currentRecord);
                        continue;
                    }
                    const prevRecord = timeSortedTrades[i - 1];
                    if (currentRecord.operation !== prevRecord.operation ||
                        currentRecord.position !== prevRecord.position) {
                        uniqueRecords.push(currentRecord);
                    }
                }
                tradeCountEl.textContent = uniqueRecords.length.toString();
            }

            if (dailyEquityData && dailyEquityData.length > 0) {
                const drawdown = calculateMaxDrawdownFromEquity(dailyEquityData);
                const maxDrawdownEl = document.getElementById('maxDrawdown');
                const maxDrawdownDaysEl = document.getElementById('maxDrawdownDays');
                if (maxDrawdownEl) {
                    maxDrawdownEl.textContent = `${drawdown.maxDrawdownPercent}%`;
                }
                if (maxDrawdownDaysEl) {
                    maxDrawdownDaysEl.textContent = `${drawdown.maxDrawdownDays}å¤©`;
                }
            }
        }

        // è®¾ç½®Kçº¿æ•°é‡é€‰æ‹©å™¨
        function setupKlineCountSelector() {
            const klineCountButtons = document.querySelectorAll('.kline-count-btn');

            klineCountButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // ç§»é™¤æ‰€æœ‰æŒ‰é’®çš„activeç±»
                    klineCountButtons.forEach(btn => btn.classList.remove('active'));

                    // ä¸ºå½“å‰ç‚¹å‡»çš„æŒ‰é’®æ·»åŠ activeç±»
                    this.classList.add('active');

                    // è·å–Kçº¿æ•°é‡
                    const klineCount = parseInt(this.getAttribute('data-count'));
                    currentKlineCount = klineCount;

                    console.log(`è®¾ç½®Kçº¿æ˜¾ç¤ºæ•°é‡: ${klineCount}`);

                    // å¦‚æœæœ‰æ•°æ®ï¼Œé‡æ–°åˆå§‹åŒ–å›¾è¡¨
                    if (currentData && currentData.trades) {
                        const klineData = generateKlineFromTrades(currentData.trades);
                        const equityData = generateEquityData(currentData.trades);
                        const returnsData = generateReturnsFromEquity(equityData);

                        initCombinedChart(klineData, returnsData, currentData.trades);
                    }
                });
            });
        }

        // åˆ·æ–°æ•°æ®
        async function refreshData() {
            try {
                const dataFile = getDataFileUrl();
                console.log('åŠ è½½æ•°æ®:', dataFile);

                const data = await loadJSON(dataFile);
                currentData = data;

                document.getElementById('mainContainer').style.display = 'block';
                showLoading(false);

                if (data.config && data.config.version) {
                    dataVersion = data.config.version;
                }

                const klineData = generateKlineFromTrades(data.trades);
                const equityData = generateEquityData(data.trades);
                const dailyEquityData = generateDailyEquityData(data.trades);
                const returnsData = generateReturnsFromEquity(equityData);

                initCombinedChart(klineData, returnsData, data.trades);
                renderTradeTable(data.trades);
                updateStats(data.trades, equityData, dailyEquityData);

                const lastUpdateEl = document.getElementById('lastUpdateTime');
                if (lastUpdateEl && data.config && data.config.lastUpdated) {
                    lastUpdateEl.textContent = data.config.lastUpdated;
                }

                console.log(`âœ… æ•°æ®åŠ è½½æˆåŠŸ`);
                console.log(`ğŸ“¦ ç‰ˆæœ¬: ${dataVersion}`);
                console.log(`ğŸ• æœ€åæ›´æ–°: ${data.config ? data.config.lastUpdated : 'æœªçŸ¥'}`);

                return true;
            } catch (error) {
                console.error('åˆ·æ–°æ•°æ®å¤±è´¥:', error);
                let errorMessage = 'æ— æ³•åŠ è½½æ•°æ®æ–‡ä»¶ã€‚';
                if (error.message.includes('404')) {
                    errorMessage = 'æ•°æ®æ–‡ä»¶æœªæ‰¾åˆ°ã€‚è¯·ç¡®ä¿data.jsonæ–‡ä»¶ä¸index.htmlåœ¨åŒä¸€ç›®å½•ä¸‹ã€‚';
                } else if (error.message.includes('Unexpected token')) {
                    errorMessage = 'æ•°æ®æ–‡ä»¶æ ¼å¼é”™è¯¯ã€‚è¯·æ£€æŸ¥data.jsonæ˜¯å¦ä¸ºæœ‰æ•ˆçš„JSONæ ¼å¼ã€‚';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'ç½‘ç»œè¯·æ±‚å¤±è´¥ã€‚è¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„å’ŒæœåŠ¡å™¨è®¾ç½®ã€‚';
                }
                showError(errorMessage);
                return false;
            }
        }

        // åˆå§‹åŒ–é¡µé¢
        async function initPage() {
            try {
                checkDisclaimer();
                await refreshData();
                // è®¾ç½®Kçº¿æ•°é‡é€‰æ‹©å™¨
                setupKlineCountSelector();

                if (currentData && currentData.config && currentData.config.autoUpdateInterval) {
                    console.log(`â° è®¾ç½®è‡ªåŠ¨æ›´æ–°é—´éš”: ${currentData.config.autoUpdateInterval}ms`);
                    setInterval(refreshData, currentData.config.autoUpdateInterval);
                }
            } catch (error) {
                console.error('é¡µé¢åˆå§‹åŒ–å¤±è´¥:', error);
                showError('é¡µé¢åˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            setTimeout(() => {
                initPage();
            }, 100);
        });
    </script>
</body>
</html>
